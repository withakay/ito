name: CI

on:
  pull_request:
    branches: [main]
  push:
    branches: [main]
  workflow_dispatch:

permissions:
  contents: read

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  autofix:
    name: Autofix (lint & format)
    if: github.event_name == 'pull_request'
    runs-on: namespace-profile-linux-amd64-4c8gb
    timeout-minutes: 10
    permissions:
      contents: write
    outputs:
      pushed: ${{ steps.push_fixes.outputs.pushed }}
    steps:
      - name: Generate GitHub App token
        id: app_token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.ITO_CI_APP_ID }}
          private-key: ${{ secrets.ITO_CI_APP_PRIVATE_KEY }}

      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          ref: ${{ github.head_ref }}
          # Use App token so pushes trigger new workflow runs
          token: ${{ steps.app_token.outputs.token }}
          fetch-depth: 2

      # Skip if the last commit was already an autofix commit (prevent loops)
      - name: Check for autofix loop
        id: loop_check
        run: |
          LAST_AUTHOR="$(git log -1 --format='%an')"
          if [[ "$LAST_AUTHOR" == "github-actions[bot]" ]]; then
            echo "skip=true" >> "$GITHUB_OUTPUT"
            echo "Last commit was from autofix bot — skipping to prevent loop."
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install build-essential
        if: steps.loop_check.outputs.skip != 'true'
        uses: ./.github/actions/cache-apt-pkgs
        with:
          packages: build-essential

      - name: Setup toolchain (mise)
        if: steps.loop_check.outputs.skip != 'true'
        uses: jdx/mise-action@v3

      - name: Install Rust components (rustfmt)
        if: steps.loop_check.outputs.skip != 'true'
        run: |
          set -eu
          mise install
          mise trust
          TOOLCHAIN="$(rustup show active-toolchain | awk '{print $1}')"
          rustup component add --toolchain "$TOOLCHAIN" rustfmt

      # --- File hygiene fixes (matching .editorconfig & .pre-commit-config.yaml) ---

      - name: Fix line endings (CRLF -> LF)
        if: steps.loop_check.outputs.skip != 'true'
        run: |
          # Convert CRLF to LF for all text files, respecting .gitattributes
          # (git handles .bat/.cmd/.ps1 CRLF via .gitattributes at checkout/commit)
          git ls-files -z | xargs -0 -P4 -I{} \
            sh -c 'file --mime "{}" | grep -q "text/" && sed -i "s/\r$//" "{}" || true'

      - name: Fix trailing whitespace
        if: steps.loop_check.outputs.skip != 'true'
        run: |
          # Trim trailing whitespace from all tracked text files EXCEPT:
          #   - *.md files (editorconfig: trailing whitespace = line breaks)
          #   - tests/** (editorconfig: snapshot files may need trailing WS)
          # But DO trim tests/**/*.rs and tests/**/*.js (editorconfig overrides)
          git ls-files -z | while IFS= read -r -d '' f; do
            # Skip binary files
            file --mime "$f" | grep -q "text/" || continue

            # Skip markdown files
            case "$f" in *.md) continue ;; esac

            # Skip tests/** unless it's a .rs or .js file
            case "$f" in
              tests/*)
                case "$f" in *.rs|*.js) ;; *) continue ;; esac
                ;;
            esac

            # Trim trailing whitespace
            sed -i 's/[[:space:]]*$//' "$f"
          done

      - name: Fix missing final newline
        if: steps.loop_check.outputs.skip != 'true'
        run: |
          # Ensure every tracked text file ends with a newline
          git ls-files -z | while IFS= read -r -d '' f; do
            [ -f "$f" ] || continue
            file --mime "$f" | grep -q "text/" || continue
            # Add newline if file is non-empty and missing one
            if [ -s "$f" ] && [ "$(tail -c1 "$f" | wc -l)" -eq 0 ]; then
              echo "" >> "$f"
            fi
          done

      - name: Format JSON files
        if: steps.loop_check.outputs.skip != 'true'
        run: |
          # Pretty-format JSON files (2-space indent, no key sorting)
          # Matches: pretty-format-json --autofix --indent=2 --no-sort-keys
          git ls-files -z '*.json' ':!tests/**' | while IFS= read -r -d '' f; do
            [ -f "$f" ] || continue
            python3 -c "
          import json, sys
          with open('$f', 'r') as fh:
              data = json.load(fh)
          with open('$f', 'w') as fh:
              json.dump(data, fh, indent=2, sort_keys=False)
              fh.write('\n')
          " 2>/dev/null || true
          done

      # --- Rust formatting ---

      - name: Rust fmt (autofix)
        if: steps.loop_check.outputs.skip != 'true'
        run: cargo fmt --all

      # --- Commit and push if anything changed ---

      - name: Commit and push fixes
        id: push_fixes
        if: steps.loop_check.outputs.skip != 'true'
        env:
          GIT_AUTHOR_NAME: "github-actions[bot]"
          GIT_AUTHOR_EMAIL: "41898282+github-actions[bot]@users.noreply.github.com"
          GIT_COMMITTER_NAME: "github-actions[bot]"
          GIT_COMMITTER_EMAIL: "41898282+github-actions[bot]@users.noreply.github.com"
        run: |
          if git diff --quiet && git diff --staged --quiet; then
            echo "No changes to commit — tree is clean."
            echo "pushed=false" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          git add -A
          git commit -m "ci: autofix lint and formatting issues

          Automated fixes applied by CI:
          - Line endings (CRLF -> LF)
          - Trailing whitespace
          - Final newlines
          - JSON formatting
          - Rust formatting (cargo fmt)"

          git push
          echo "pushed=true" >> "$GITHUB_OUTPUT"
          echo "::notice::Autofix pushed changes — a new CI run will validate the fixed code."

  test:
    name: Test (linux)
    needs: [autofix]
    # Run when autofix is skipped (push to main, workflow_dispatch) or succeeded
    # without pushing. If autofix pushed, a new CI run handles checks instead.
    if: |
      always()
      && (needs.autofix.result == 'success' || needs.autofix.result == 'skipped')
      && needs.autofix.outputs.pushed != 'true'
    #runs-on: withakay-selfhosted
    runs-on: namespace-profile-linux-amd64-4c8gb
    timeout-minutes: 10

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install build-essential
        uses: ./.github/actions/cache-apt-pkgs
        with:
          packages: build-essential

      - name: Setup toolchain (mise)
        uses: jdx/mise-action@v3

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target
          shared-key: ci-test-linux
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target

      - name: Print environment diagnostics
        run: |
          mise install
          mise trust
          rustc -V
          cargo -V

      - name: Test
        env:
          CARGO_REGISTRIES_CRATES_IO_PROTOCOL: sparse
        run: cargo test --workspace --exclude ito-web

  lint:
    name: Lint & Type Check
    needs: [autofix]
    if: |
      always()
      && (needs.autofix.result == 'success' || needs.autofix.result == 'skipped')
      && needs.autofix.outputs.pushed != 'true'
    # runs-on: withakay-selfhosted
    runs-on: namespace-profile-linux-amd64-4c8gb
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build-essential
        uses: ./.github/actions/cache-apt-pkgs
        with:
          packages: build-essential

      - name: Setup toolchain (mise)
        uses: jdx/mise-action@v3

      - name: Install Rust components (rustfmt, clippy)
        run: |
          set -eu
          mise install
          mise trust
          TOOLCHAIN="$(rustup show active-toolchain | awk '{print $1}')"
          rustup component add --toolchain "$TOOLCHAIN" rustfmt clippy

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target
          shared-key: ci-lint
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target

      - name: Verify config schema artifact is current
        run: |
          make config-schema-check

      - name: Rust fmt (check)
        run: cargo fmt --all -- --check

      - name: Rust clippy
        run: |
          cargo clippy --workspace --all-targets -- \
            -D warnings \
            -D clippy::dbg_macro \
            -D clippy::todo \
            -D clippy::unimplemented

  arch_guardrails:
    name: Architecture Guardrails
    needs: [autofix]
    if: |
      always()
      && (needs.autofix.result == 'success' || needs.autofix.result == 'skipped')
      && needs.autofix.outputs.pushed != 'true'
    # runs-on: withakay-selfhosted
    runs-on: namespace-profile-linux-amd64-4c8gb
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install build-essential
        uses: ./.github/actions/cache-apt-pkgs
        with:
          packages: build-essential

      - name: Setup toolchain (mise)
        uses: jdx/mise-action@v3

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target
          shared-key: ci-arch-guardrails
          save-if: ${{ github.ref == 'refs/heads/main' }}

      - name: Cache Rust dependencies
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: . -> target

      - name: Print environment diagnostics
        run: |
          mise install
          mise trust
          rustc -V
          cargo -V

      - name: Run architecture guardrails
        run: make arch-guardrails

      - name: Install cargo-deny
        uses: taiki-e/install-action@cargo-deny

      - name: Run cargo-deny (license/advisory checks)
        run: cargo deny check

  required-checks-pr:
    name: All checks passed
    # runs-on: ubuntu-latest
    runs-on: namespace-profile-linux-amd64-4c8gb
    needs: [autofix, test, lint, arch_guardrails]
    if: always() && github.event_name == 'pull_request'
    steps:
      - name: Verify all checks passed
        run: |
          # If autofix pushed, downstream jobs were intentionally skipped.
          # A new CI run will validate the fixed code — this run is superseded.
          if [[ "${{ needs.autofix.outputs.pushed }}" == "true" ]]; then
            echo "Autofix pushed changes — deferring checks to the new CI run."
            exit 0
          fi

          if [[ "${{ needs.test.result }}" != "success" ]]; then
            echo "Test job failed"
            exit 1
          fi
          if [[ "${{ needs.lint.result }}" != "success" ]]; then
            echo "Lint job failed"
            exit 1
          fi
          if [[ "${{ needs.arch_guardrails.result }}" != "success" ]]; then
            echo "Architecture guardrails job failed"
            exit 1
          fi
          echo "All required checks passed!"

  required-checks-main:
    name: All checks passed
    # runs-on: withakay-selfhosted
    runs-on: namespace-profile-linux-amd64-4c8gb
    needs: [test, lint, arch_guardrails]
    if: always() && github.event_name != 'pull_request'
    steps:
      - name: Verify all checks passed
        run: |
          if [[ "${{ needs.test.result }}" != "success" ]]; then
            echo "Test job failed"
            exit 1
          fi
          if [[ "${{ needs.lint.result }}" != "success" ]]; then
            echo "Lint job failed"
            exit 1
          fi
          if [[ "${{ needs.arch_guardrails.result }}" != "success" ]]; then
            echo "Architecture guardrails job failed"
            exit 1
          fi
          echo "All required checks passed!"
