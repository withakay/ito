name: tdd
version: 1
description: Test-driven development workflow - tests -> implementation -> docs
artifacts:
  - id: spec
    generates: spec.md
    description: Feature specification defining requirements
    template: spec.md
    instruction: |
      Create the feature specification that defines WHAT to build.

      Sections:
      - **Feature**: Name and high-level description of the feature's purpose and user value
      - **Requirements**: List of specific requirements. Use SHALL/MUST for normative language.
      - **Acceptance Criteria**: Testable criteria in WHEN/THEN format

      Format requirements:
      - Each requirement should be specific and testable
      - Use `#### Scenario: <name>` with WHEN/THEN format for acceptance criteria
      - Define edge cases and error scenarios explicitly
      - Every requirement MUST have at least one scenario

      This spec drives test creation — each scenario becomes a test case.
    requires: []

  - id: tests
    generates: "tests/*"
    description: Test files written before implementation
    template: test.md
    instruction: |
      Write tests BEFORE implementation (TDD red phase).

      File naming:
      - Create test files using the project's conventions (e.g., `tests/test_<feature>.py`, `tests/<feature>_test.go`, `<feature>.test.ts`)
      - One test file per feature/capability
      - Use descriptive names matching the spec

      Test structure:
      - Use Given/When/Then format matching spec scenarios
      - Group related tests logically (test classes, describe blocks, sub-tests — whatever the language idiom is)
      - Each scenario from spec becomes at least one test case

      Coverage requirements:
      - Cover each requirement from the spec
      - Include happy path (success cases)
      - Include edge cases (boundary conditions)
      - Include error scenarios (invalid input, failures)
      - Tests should fail initially (no implementation yet)

      Follow the spec requirements exactly — tests verify the spec.
    requires:
      - spec

  - id: implementation
    generates: "src/*"
    description: Implementation code to pass the tests
    template: implementation.md
    instruction: |
      Implement the feature to make tests pass (TDD green phase).

      TDD workflow:
      1. Run tests — confirm they fail (red)
      2. Write minimal code to pass ONE test
      3. Run tests — confirm that test passes (green)
      4. Refactor if needed while keeping tests green
      5. Repeat for next failing test

      Implementation guidelines:
      - Write minimal code to pass each test — no more, no less
      - Run tests frequently to verify progress
      - Keep functions small and focused
      - Use clear, descriptive names
      - Follow the project's existing code style and conventions

      Don't over-engineer — implement only what tests require.
    requires:
      - tests

  - id: docs
    generates: "docs/*.md"
    description: Documentation for the implemented feature
    template: docs.md
    instruction: |
      Document the implemented feature.

      Sections:
      - **Overview**: What the feature does and why it exists (1-2 paragraphs)
      - **Getting Started**: Quick start guide to use the feature immediately
      - **Examples**: Code examples showing common use cases
      - **Reference**: Detailed API documentation, configuration options

      Guidelines:
      - Write for the user, not the developer
      - Start with the most common use case
      - Include copy-pasteable code examples
      - Document all configuration options with defaults
      - Note any limitations, edge cases, or gotchas

      Reference the spec for requirements, implementation for details.
    requires:
      - implementation

apply:
  requires: [tests]
  tracks: null
  instruction: |
    Run tests to see failures. Implement minimal code to pass each test.
    Refactor while keeping tests green.
